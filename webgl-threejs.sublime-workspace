{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"new",
				"newCity\tlocal var"
			],
			[
				"GridPo",
				"GridPosition\tclass"
			],
			[
				"component",
				"componentName\tparameter"
			],
			[
				"text",
				"textureLoader"
			],
			[
				"grid",
				"grid\tproperty"
			],
			[
				"plane",
				"planeGeometry"
			],
			[
				"gridS",
				"gridSizeHeight"
			],
			[
				"griSi",
				"gridSizeHeight"
			],
			[
				"pointY",
				"pointY"
			],
			[
				"gridSize",
				"gridSizeWidth"
			],
			[
				"generateCit",
				"generateCityName"
			],
			[
				"generate",
				"generateWomanNpc"
			],
			[
				"_tileren",
				"_tilesRenderY\tInt"
			],
			[
				"_last",
				"_lastSceneY\tFloat"
			],
			[
				"_tiles",
				"_tilesRenderY\tInt"
			],
			[
				"remo",
				"removeTiles(...)\tVoid"
			],
			[
				"_groun",
				"_groundTileLayer\topenfl.display.Tilemap"
			],
			[
				"Sc",
				"scaleY\tFloat"
			],
			[
				"_tile",
				"_TILESIZE\tInt"
			],
			[
				"p",
				"getPhase(  )\tInt"
			],
			[
				"_move",
				"_moveLeft\tBool"
			],
			[
				"get",
				"getTileIndex(...)\tInt"
			],
			[
				"tiles",
				"_TILESIZE\tInt"
			],
			[
				"com",
				"componentName"
			],
			[
				"Spri",
				"Sprite\topenfl.display"
			],
			[
				"Recta",
				"Rectangle\topenfl.geom"
			],
			[
				"_grid",
				"_gridTileMap"
			],
			[
				"_gr",
				"_gridTileMap"
			],
			[
				"Ve",
				"Vector<T>\topenfl"
			],
			[
				"_g",
				"_gridTileMap"
			],
			[
				"_",
				"_mainSprite\topenfl.display.Sprite"
			],
			[
				"che",
				"checkedScene"
			],
			[
				"add",
				"addChild(...)\topenfl.display.DisplayObject"
			],
			[
				"remove",
				"removeChild(...)\topenfl.display.DisplayObject"
			],
			[
				"addChil",
				"addChildAt(...)\topenfl.display.DisplayObject"
			],
			[
				"child",
				"addChildAt(...)\topenfl.display.DisplayObject"
			],
			[
				"_exit",
				"_exitGameButtonPushed"
			],
			[
				"_ex",
				"_exitGameButtonPushed\tvar"
			],
			[
				"_start",
				"_startGameButtonPushed\tvar"
			],
			[
				"strin",
				"String\tclass"
			],
			[
				"Void",
				"Void\tclass"
			],
			[
				"User",
				"UserInterface\tclass"
			],
			[
				"Mouse",
				"MouseEvent\topenfl.events"
			],
			[
				"dotPo",
				"dotPositionY\tvar"
			],
			[
				"my",
				"_myScene\tPlayingScene"
			],
			[
				"is",
				"_isReachDestinationPoint\tBool"
			],
			[
				"tilepO",
				"tilePosY\tInt"
			],
			[
				"Pat",
				"pathfinder\tpackage"
			],
			[
				"Pa",
				"Pathfinder\tpathfinder"
			],
			[
				"Vectr",
				"Vector<T>\thaxe.ds"
			],
			[
				"Vector",
				"Vector<T>\thaxe.ds"
			],
			[
				"_path",
				"_pathfinderMap"
			],
			[
				"Pathfin",
				"pathfinder\tpackage"
			],
			[
				"Pathfi",
				"PathfinderMap\tclass"
			],
			[
				"PAthfinde",
				"PathfinderMap\tclass"
			],
			[
				"Bitmap",
				"Bitmap\topenfl.display"
			],
			[
				"bitmap",
				"Bitmap\topenfl.display"
			],
			[
				"gr",
				"gridSize\tInt"
			],
			[
				"tile",
				"tileGroundSize\tInt"
			],
			[
				"Po",
				"Point\topenfl.geom"
			],
			[
				"cells",
				"cellsArray"
			],
			[
				"cur",
				"currentId"
			],
			[
				"las",
				"lastChild"
			],
			[
				"cha",
				"changeColor"
			],
			[
				"Bit",
				"Bitmap\topenfl.display"
			],
			[
				"scle",
				"scaleY\tFloat"
			],
			[
				"Lib",
				"Lib\topenfl"
			],
			[
				"TextFor",
				"TextFormatAlign\tflash.text"
			],
			[
				"TextField",
				"TextField\topenfl.text"
			],
			[
				"onKe",
				"onKeyDown(...)\tVoid"
			],
			[
				"K",
				"KEY_DOWN\tString"
			],
			[
				"Ke",
				"KeyboardEvent\tflash.events"
			],
			[
				"Key",
				"KeyboardEvent\topenfl.events"
			],
			[
				"ground",
				"groundType"
			],
			[
				"gro",
				"groundType\tInt"
			],
			[
				"cure",
				"currentRockSizeX"
			],
			[
				"last",
				"lastSizeX"
			],
			[
				"rock",
				"rocksMinSize\tvar"
			],
			[
				"ro",
				"rocksMaxSize\tvar"
			],
			[
				"MouseEv",
				"MouseEvent\topenfl.events"
			],
			[
				"event",
				"Event\topenfl.events"
			],
			[
				"Mou",
				"MouseEvent\topenfl.events"
			],
			[
				"Event",
				"Event\topenfl.events"
			],
			[
				"Rect",
				"Rectangle\topenfl.geom"
			],
			[
				"Tile",
				"Tile\topenfl.display"
			],
			[
				"rocks",
				"rocksMinSize\tInt"
			],
			[
				"genertae",
				"generateWater(...)\tVoid"
			],
			[
				"create",
				"createWaterTile(  )\tVoid"
			],
			[
				"maxNub",
				"maxNumberOfWater\tvar"
			],
			[
				"Rock",
				"Rock"
			],
			[
				"TextFo",
				"TextFormat\topenfl.text"
			],
			[
				"dra",
				"drawRoundRect(...)\tVoid"
			],
			[
				"startGameBut",
				"startGameButtonText\topenfl.text.TextField"
			],
			[
				"start",
				"startGameButtonText"
			],
			[
				"s",
				"Sprite"
			],
			[
				"E",
				"Event\tclass"
			],
			[
				"weapo",
				"weaponSprite"
			],
			[
				"remov",
				"removeChild(...)\topenfl.display.DisplayObject"
			],
			[
				"rem",
				"removeWeapon(  )\tUnknown<9>"
			],
			[
				"Get",
				"getSprite(  )\tUnknown<2>"
			],
			[
				"M",
				"MOUSE_MOVE\tString"
			],
			[
				"mouse",
				"MouseEvent\tflash.events"
			],
			[
				"set",
				"setAsBox( hx : Float , hy : Float )\tVoid"
			],
			[
				"B2B",
				"B2BodyDef\tbox2D.dynamics"
			],
			[
				"turn",
				"myGameTurnControl\tGameTurnControl"
			],
			[
				"_all",
				"_allPlayerOnScene\tArray<Dynamic>"
			],
			[
				"Scne",
				"ScenePlayerActor\tclass"
			],
			[
				"stage",
				"stageHeight\tInt"
			],
			[
				"tage",
				"stageWidth\tInt"
			],
			[
				"stag",
				"stageWidth\tInt"
			],
			[
				"rec",
				"scrollRect\topenfl.geom.Rectangle"
			],
			[
				"Timer",
				"Timer\tflash.utils"
			],
			[
				"textF",
				"TextFieldType\tflash.text"
			],
			[
				"Scene",
				"ScenePlayerActor\tclass"
			],
			[
				"max",
				"maxSceneHeight\tInt"
			],
			[
				"sc",
				"scaleX\tFloat"
			],
			[
				"maxWid",
				"maxWidthPerPolygon\tFloat"
			],
			[
				"maxWi",
				"maxWidthPerPolygon\tFloat"
			],
			[
				"coord",
				"coordsArray\tArray<Dynamic>"
			],
			[
				"cre",
				"createFixture"
			],
			[
				"polygon",
				"polygonArray"
			],
			[
				"wor",
				"worldScale"
			],
			[
				"right",
				"rightVertexY\tvar"
			],
			[
				"nextR",
				"nextRightVertexX"
			],
			[
				"left",
				"leftVertexX"
			],
			[
				"nextRigh",
				"nextRightVertexY\tvar"
			],
			[
				"next",
				"nextRightVertexX\tvar"
			],
			[
				"B2Fixture",
				"B2FixtureDef\tbox2D.dynamics"
			]
		]
	},
	"buffers":
	[
		{
			"file": "js/game.js",
			"settings":
			{
				"buffer_size": 1722,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "js/services.js",
			"settings":
			{
				"buffer_size": 5145,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "declare var THREE: any;\ndeclare var Detector: any;\ndeclare var Stats: any;\n\nclass GridPoint {\n\n\tpublic gridId: number;\n\tpublic pointType: number; // 0-liquid, 1 - flat, 2 - cubic;\n\tpublic coverType: number; // 0 - free ; 1 - water; 2 - lava; 3 - swamp; 4 - earth; 5 - sand; 6 - road; 7 - forest; 8 - rocks; 9 - city;\n\tpublic effectType: number; // 0 - nothing, 1 - fire, 2 - wet, 3 - snow, 4- blood;\n\tpublic movementRatio: number; // 1- normal. 2- superfast - 0.1 - minimum speed;\n\tpublic graphicIndex:number; // index need for graphics;\n\tpublic gridCoords: any; // coordinates where this tile in grid;\n\n\tconstructor (id, point, cover, effect, speed, newIndex, coords){\n\t\tthis.gridId = id;\n\t\tthis.pointType = point;\n\t\tthis.coverType = cover;\n\t\tthis.effectType = effect;\n\t\tthis.movementRatio = speed;\n\t\tthis.graphicIndex = newIndex;\n\t\tthis.gridCoords = coords;\n\t}\n}\n\nclass GridCoordinates {\n\t//grid coords;\n\tpublic x:number;\n\tpublic y:number;\n\n\tconstructor (newX, newY){\n\t\tthis.x = newX;\n\t\tthis.y = newY;\n\t}\n\n}\n\nclass GroundMap{\n\tpublic width:number;\n\tpublic height:number;\n\tpublic size:number;\n\tpublic logicGrid:Array<any>;\n\n\tprivate cityCoordinatesArray:Array<any>;\n\n\tconstructor(width, height){\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.size = width*height;\n\t\tthis.logicGrid = new Array();\n\t\tthis.cityCoordinatesArray = new Array();\n\t}\n\n\tpublic generateBiomMap( primaryGroundBiom, params):void{ //{ \"Earth\" : [amount, width, height, offset, step, maxWidth], \"Sand\" : [amount, width, height, offset, step, maxWidth]...}\n\t\tthis.fillLogicGrid( primaryGroundBiom ); // { \"Lake/River\"}\n\t\tfor( var key in params ){\n\n\t\t}\n\t}\n\n\tprivate fillLogicGrid(type):void{\n\t\tvar coverType;\n\t\tvar pointType;\n\t\tvar movementRatio;\n\n\t\tif( type == \"Earth\" ){\n\t\t\tcoverType = 4;\n\t\t\tpointType = 1;\n\t\t\tmovementRatio = 0.8;\n\t\t}else if( type == \"Sand\" ){\n\t\t\tcoverType = 5;\n\t\t\tpointType = 1;\n\t\t\tmovementRatio = 0.6;\n\t\t}else{\n\t\t\t//default earth\n\t\t\tcoverType = 4;\n\t\t\tpointType = 1;\n\t\t\tmovementRatio = 0.8;\n\t\t}\n\n\t\tfor (var y = 0; y < this.height; y++){\n\t\t\tfor (var x = 0; x < this.width; x++){\n\t\t\t\tvar gridId = y*this.height + x;\n\t\t\t\tvar coords = new GridCoordinates(x, y);\n\t\t\t\tvar newGridPoint = new GridPoint(gridId, pointType, coverType, 0, movementRatio, 0, coords); //earth;\n\t\t\t\tthis.logicGrid.push(newGridPoint);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic generateCities( type, amount, safeZoneNum, minRad ):any{\n\t\tvar cityAmount = amount || Math.min(Math.round(this.width/5), Math.round(this.height/5)); // default;\n\t\tvar safeZone = safeZoneNum || 2; //default;\n\t\tvar minRadius = minRad || Math.round((this.width+this.height)/(2*amount)); //default\n\t\tvar temporaryArrayForCheckCoords = new Array();\n\t\tfor (var i = 0; i < cityAmount; i++){\n\t\t\tvar pointX = Math.floor(Math.random()*(this.width - safeZone*2) + safeZone);\n\t\t\tvar pointY = Math.floor(Math.random()*(this.height - safeZone*2) + safeZone);\n\t\t\tvar check = true;\n\t\t\t//проверяем, есть ли по близости город, в пределах минимального радиуса.\n\t\t\tfor (var j = 0; j < temporaryArrayForCheckCoords.length; j++){\n\t\t\t\tvar cityX = temporaryArrayForCheckCoords[j].x;\n\t\t\t\tvar cityY = temporaryArrayForCheckCoords[j].y;\n\n\t\t\t\tvar difX = Math.abs(cityX - pointX);\n\t\t\t\tvar difY = Math.abs(cityY - pointY);\n\n\t\t\t\tvar coordDif = Math.round(Math.sqrt(difX*difX + difY*difY));\n\n\t\t\t\tif (coordDif <= minRadius)\n\t\t\t\t\tcheck = false;\n\t\t\t}\n\n\t\t\tif (check){\n\t\t\t\tvar newCoords = new GridCoordinates( pointX, pointY );\n\t\t\t\ttemporaryArrayForCheckCoords.push( newCoords );\n\t\t\t\tvar gridId = pointY*this.height + pointX;\n\t\t\t\tthis.logicGrid[gridId].coverType = 9;\n\t\t\t\tthis.logicGrid[gridId].pointType = 2;\n\t\t\t\tthis.logicGrid[gridId].movementRatio = 1;\n\t\t\t}else{\n\t\t\t\ti--;\n\t\t\t}\n\n\t\t}\n\n\t\treturn temporaryArrayForCheckCoords;\n\t}\n\n\t//angular -  будет ли река поворачивать на 90 градусов ( true; false); type - 0 - simple river, 1 - river with lake, 2 - river with solid;\n\tprivate generateRiver(type, angular, width, offset, step, maxWidth, minWidth){\n\t\tvar liquidWidth = width || Math.round(this.width*0.05); //max 5%;\n\t\tvar liquidAngulatChanse = angular || false; // no chanse on default;\n\t\tvar liquidType = type || 0; //simple river default;\n\t\tvar liquidOffset = offset || 1; //max 1;\n\t\tvar liquidStep = step || 1; //max 1;\n\t\tvar liquidMaxWidth = maxWidth || (liquidWidth + 5) // max +5;\n\t\tvar liquidMinWidth = minWidth || 0;// 0 - river can be underground;\n\n\t\tvar startingPointY = Math.floor(Math.random()*(this.height/2 + 1)); // max start on half of grid on Y;\n\t\tvar startingPointX = Math.floor(Math.random()*(this.width - liquidWidth + 1));\n\t\tvar liquidHeight;\n\n\t\tif (liquidType == 0)\n\t\t{\n\t\t\tstartingPointY = 0;\n\t\t\tliquidHeight = this.height;\n\t\t} \n\n\t\tvar liquidCurrentWidth = liquidWidth;\n\t\tvar nextPointX = startingPointX;\n\n\t\t// no angular, no lakes and solids, right now only simple RiverL\n\n\t\tfor (var j = 0; j < liquidHeight; j++){\n\n\t\t\tif (j != 0){\n\t\t\t\tvar liquidCurrentStep = Math.floor(Math.random()*(liquidStep*2 + 1) -liquidStep); \n\t\t\t\tvar liquidDirectionOffset = Math.floor(Math.random()*(liquidOffset*2 + 1) -liquidOffset); // -1 left, 0 - center, +1 - right;\n\t\t\t\tliquidCurrentWidth = liquidCurrentWidth + liquidCurrentStep;\n\t\t\t\tnextPointX += liquidDirectionOffset;\n\t\t\t\tif (liquidCurrentWidth > liquidMaxWidth)\n\t\t\t\t\tliquidCurrentWidth = liquidMaxWidth;\n\t\t\t\telse if (liquidCurrentWidth < liquidMinWidth)\n\t\t\t\t\tliquidCurrentWidth = liquidMinWidth;\n\t\t\t\telse if (liquidCurrentWidth == 1)\n\t\t\t\t\tnextPointX -= liquidDirectionOffset;\n\n\t\t\t}\n\n\t\t\tfor (var k = 0; k < liquidCurrentWidth; k++){\n\t\t\t\tvar gridIndex = (startingPointY + j) * this.height + (nextPointX + k);\n\n\t\t\t\t//проверяем, принадлежит ли наш индекс строке Y, на которой мы хотим разместить часть объекта;\n\t\t\t\tif (gridIndex >= (startingPointY + j) * this.height && gridIndex < (startingPointY + j + 1) * this.height){\n\t\t\t\t\tvar point = this.logicGrid[gridIndex];\n\t\t\t\t\tpoint.pointType = 0; // water\n\t\t\t\t\tpoint.movementRatio = 0.4;\n\t\t\t\t\tpoint.coverType = 1 // water;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// generating with WIDTH, so height is static; \n\t//offset - есть ли смещение влево или вправо и на сколько, step - на сколько сильно может уменьшаться или увеличиваться объект с каждой последующей Y  координатой;\n\tprivate generateGroundMapObjects(type, amount, width, height, offset, step, maxWidth){\n\n\t\tvar pointType;\n\t\tvar movementRatio;\n\t\tvar coverType;\n\t\tif (type == \"Lake\"){\n\t\t\tpointType = 0;\n\t\t\tmovementRatio = 0.4;\n\t\t\tcoverType = 1;\n\t\t}else if (type == \"Rocks\"){\n\t\t\tpointType = 2;\n\t\t\tmovementRatio = 0.2;\n\t\t\tcoverType = 8;\n\t\t}else if (type == \"Forest\"){\n\t\t\tpointType = 2;\n\t\t\tmovementRatio = 0.7;\n\t\t\tcoverType = 7;\n\t\t}else if( type == \"Swamp\" ){\n\t\t\tpointType = 1;\n\t\t\tmovementRatio = 0.5;\n\t\t\tcoverType = 3;\n\t\t}else if( type == \"Earth\" ){\n\t\t\tpointType = 1;\n\t\t\tmovementRatio = 0.8;\n\t\t\tcoverType = 4;\n\t\t}else if( type == \"Sand\" ){\n\t\t\tpointType = 1;\n\t\t\tmovementRatio = 0.5;\n\t\t\tcoverType = 5;\n\t\t}else if( type == \"Lava\" ){\n\t\t\tpointType = 0;\n\t\t\tmovementRatio = 0;\n\t\t\tcoverType = 2;\n\t\t}else if( type == \"Oil\" ){\n\t\t\tpointType = 0;\n\t\t\tmovementRatio = 0;\n\t\t\tcoverType = 0;\n\t\t}\n\n\t\tvar liquidAmount = amount || 1; // max 1\n\t\tvar liquidWidth = width || Math.round(this.width/10) // max 10%\n\t\tvar liquidHeight = height || Math.round(this.height/10) // max 10%\n\t\tvar liquidOffset = offset || 1; //max 1;\n\t\tvar liquidStep = step || 1; //max 1;\n\t\tvar liquidMaxWidth = maxWidth || (liquidWidth + 5); // max +5;\n\t\tvar liquidMinWidth = 1; //default;\n\n\t\tfor (var i = 0; i < liquidAmount; i++)\n\t\t{\n\t\t\t// для того, что бы вписать объект, что бы он не выходил за границы, сделаю стартовые точки с учетом длинны и ширины объекта.\n\t\t\tvar startingPointY = Math.floor(Math.random()*(this.height - liquidHeight + 1));\n\t\t\tvar startingPointX = Math.floor(Math.random()*(this.width - liquidWidth + 1));\n\t\t\tvar liquidCurrentWidth = liquidWidth;\n\t\t\tvar nextPointX = startingPointX;\n\n\t\t\tfor (var j = 0; j < liquidHeight; j++){\n\n\t\t\t\tif (j != 0){\n\t\t\t\t\tvar liquidCurrentStep = Math.floor(Math.random()*(liquidStep*2 + 1) -liquidStep); \n\t\t\t\t\tvar liquidDirectionOffset = Math.floor(Math.random()*(liquidOffset*2 + 1) -liquidOffset); // -1 left, 0 - center, +1 - right;\n\t\t\t\t\tliquidCurrentWidth = liquidCurrentWidth + liquidCurrentStep;\n\t\t\t\t\tnextPointX = nextPointX + liquidDirectionOffset;\n\t\t\t\t\tif (liquidCurrentWidth > liquidMaxWidth)\n\t\t\t\t\t\tliquidCurrentWidth = liquidMaxWidth;\n\t\t\t\t\telse if(liquidCurrentWidth == 1)\n\t\t\t\t\t\tnextPointX -= liquidDirectionOffset;\n\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\tfor (var k = 0; k < liquidCurrentWidth; k++){\n\t\t\t\t\tvar gridIndex = (startingPointY + j) * this.height + (nextPointX + k);\n\t\t\t\t\t//проверяем, принадлежит ли наш индекс строке Y, на которой мы хотим разместить часть объекта;\n\t\t\t\t\tif (gridIndex >= (startingPointY + j) * this.height && gridIndex < (startingPointY + j + 1) * this.height){\n\t\t\t\t\t\tvar point = this.logicGrid[gridIndex];\n\t\t\t\t\t\tpoint.pointType = pointType;\n\t\t\t\t\t\tpoint.movementRatio = movementRatio;\n\t\t\t\t\t\tpoint.coverType = coverType;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//amount - количество дорог идущих от 1 города ( максимум );\n\tpublic generateRoadFromCityToCity( amount ){\n\t\tvar roadAmount = amount || 2; //2 max;\n\n\t\tfor ( var i = 0; i < this.logicGrid.length; i++){\n\t\t\tvar point = this.logicGrid[i];\n\t\t\tvar distanceArray = null;\n\t\t\tif ( point.coverType == 9 ){ //city \n\t\t\t\tfor (var j = 0; j < this.cityCoordinatesArray.length; j++){\n\t\t\t\t\tvar city = this.cityCoordinatesArray[j];\n\t\t\t\t\tif ( city.getComponent('City').gridId == i){\n\t\t\t\t\t\tdistanceArray = this.calculateDistanceFromCity(city);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (distanceArray != null){\n\t\t\t\tfor (var j = 0; j < roadAmount; j++){\n\t\t\t\t\tthis.createRoadFromCityToCity(city, distanceArray);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate createRoadFromCityToCity(city, citiesArray){\n\t\tvar newCity = null;\n\t\tvar currentCity = city.getComponent('City');\n\n\t\tfor( var k = 0; k < citiesArray.length; k++ ){\n\t\t\tvar tempCity = citiesArray[k].getComponent('City');\n\t\t\tif (tempCity.name != currentCity.name && !tempCity.checkRoadToCity(currentCity.name)){\n\t\t\t\tnewCity = tempCity;\n\t\t\t\tif( k > 1 ){\n\t\t\t\t\tvar previousCity = citiesArray[k-1].getComponent('City');\n\t\t\t\t\tif( !newCity.checkRoadToCity(previousCity.name) )\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (newCity == null)\n\t\t\treturn;\n\n\n\t\tvar pointX = currentCity.gridCoordinates.x;\n\t\tvar pointY = currentCity.gridCoordinates.y;\n\t\tvar toPointX = newCity.gridCoordinates.x;\n\t\tvar toPointY = newCity.gridCoordinates.y;\n\n\t\tvar nextPointX = pointX;\n\t\tvar nextPointY = pointY;\n\n\t\twhile(true){\n\n\t\t\tvar difX = nextPointX - toPointX;\n\t\t\tvar difY = nextPointY - toPointY;\n\n\t\t\tvar directionX = 0\n\t\t\tvar directionY = 0\n\n\t\t\tif (difX < 0)\n\t\t\t\tdirectionX = 1;\n\t\t\telse if (difX > 0)\n\t\t\t\tdirectionX = -1;\n\n\t\t\tif (difY < 0)\n\t\t\t\tdirectionY = 1;\n\t\t\telse if (difY > 0)\n\t\t\t\tdirectionY = -1;\n\n\n\t\t\tif (Math.abs(difX) > Math.abs(difY)){\n\t\t\t\tif (difX != 0){\n\t\t\t\t\tnextPointX += directionX;\n\t\t\t\t\tvar gridIndex = nextPointY*this.height + nextPointX;\n\t\t\t\t\tvar point = this.logicGrid[gridIndex];\n\n\t\t\t\t\tif (point.coverType != 9){\n\t\t\t\t\t\tpoint.pointType = 1; // flat tile;\n\t\t\t\t\t\tpoint.coverType = 6; // road\n\t\t\t\t\t\tpoint.movementRatio = 1; // normal\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif (difY != 0){\n\t\t\t\t\tnextPointY += directionY;\n\t\t\t\t\tvar gridIndex = nextPointY*this.height + nextPointX;\n\t\t\t\t\tvar point = this.logicGrid[gridIndex];\n\n\t\t\t\t\tif (point.coverType != 9){\n\t\t\t\t\t\tpoint.pointType = 1; // flat tile;\n\t\t\t\t\t\tpoint.coverType = 6; // road\n\t\t\t\t\t\tpoint.movementRatio = 1; // normal\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//exit from endless loop;\n\t\t\tif (difX == 0 && difY == 0){\n\t\t\t\tcurrentCity.roadAmount ++;\n\t\t\t\tcurrentCity.addRoadToCity(newCity.name);\n\t\t\t\tnewCity.roadAmount ++;\n\t\t\t\tnewCity.addRoadToCity(currentCity.name);\n\t\t\t\tbreak; \n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\tprivate calculateDistanceFromCity(city):Array<any>{ //return Array of numbers;\n\t\tvar dsArray = new Array();\n\t\tvar temporary = new Array();\n\t\tvar result = new Array();\n\n\t\tvar pointX = city.getComponent(\"City\").gridCoordinates.x;\n\t\tvar pointY = city.getComponent(\"City\").gridCoordinates.y;\n\n\t\t//собираем информацию о дистанции до города со всех городов.\n\t\tfor (var i = 0 ; i < this.citiesArray.length; i++){\n\t\t\tvar newCity = this.citiesArray[i];\n\t\t\tvar newCityName = newCity.getComponent('City').name;\n\t\t\tvar newPointX = newCity.getComponent(\"City\").gridCoordinates.x;\n\t\t\tvar newPointY = newCity.getComponent(\"City\").gridCoordinates.y;\n\n\t\t\tvar difX = Math.abs(pointX - newPointX);\n\t\t\tvar difY = Math.abs(pointX - newPointX);\n\t\t\tvar dif = Math.round(Math.sqrt(difX*difX + difY*difY));\n\n\t\t\tdsArray.push(dif); // пушим дистанцию\n\t\t}\n\n\t\ttemporary = dsArray.slice(); // copy;\n\n\t\ttemporary.sort(function(a,b){ return a-b;}); // сортируем.\n\n\t\t//делаем отправной массив с ссылками на города. но в порядке от самых ближайших городов до самых дальних.\n\t\tfor (var j = 0; j <dsArray.length; j++){\n\t\t\tvar searchNum = temporary[j];\n\t\t\tvar index = dsArray.indexOf(searchNum);\n\t\t\tresult.push(this.citiesArray[index]);\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tpublic generateCityEntities( entityRoot, coordsArray ){\n\n\n\t\tvar newCity = entityRoot.createEntity( \"City\" );\n\t\tvar component = newCity.createComponent( \"City\" );\n\t\tnewCity.addComponent( component );\n\n\t\tcomponent = newCity.createComponent( \"Name\" );\n\t\tcomponent.init( null, namesArray );\n\t\tcomponent.generateSurname();\n\t\tnewCity.addComponent( component );\n\n\t\tcomponent = newCity.createComponent( \"GridPosition\" );\n\t\tcomponent.changePosition( pointX, pointY );\n\t\tcomponent.gridId = gridId;\n\t\tnewCity.addComponent( component );\n\n\t\tthis.citiesArray.push( newCity );\n\t}\n\n\n}\n\nclass Graphics {\n\tpublic camera:any;\n\tpublic scene:any;\n\tpublic renderer:any;\n\tpublic stats:any;\n\tpublic container:any;\n\tpublic grid:any;\n\n\tpublic directionalLight:any;\n\tpublic hemiLight:any;\n\tpublic spotLight:any;\n\n\tpublic tileSize:number;\n\n\tpublic firstGroundLayer:any;\n\tpublic secondGroundLayer:any;\n\n\tconstructor(tileSize){\n\t\tthis.tileSize = tileSize;\n\t}\n\n\tpublic init():void{\n\t\t//primary DOM element;\n\t\tthis.container = document.getElementById( 'canvas' );\n\n\t\t//scene\n\t\tthis.scene = new THREE.Scene();\n\n\t\t//camera\n\t\tthis.camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -5000, 10000 ); //-500, 1000\n\t\tthis.camera.position.set(200,100,200);\n\t\tthis.camera.lookAt( new THREE.Vector3(0,0,0) );\n\n\t\t//renderer\n\t\tif (Detector.webgl) {\n\t\t\tthis.renderer = new THREE.WebGLRenderer( { antialias: false } );\n\t\t} else {\n\t\t\tthis.renderer = new THREE.CanvasRenderer();\n\t\t\tthis.renderer.setPixelRatio( window.devicePixelRatio );\n\t\t}\n\n\t\tthis.renderer.setClearColor( 0x999999 );\n\t\tthis.renderer.setSize( window.innerWidth - 10, window.innerHeight - 10 );\n\t\tthis.renderer.sortObjects = false;\n\t\t//this.renderer.shadowMapEnabled = true;\n\t\t\n\t\tthis.container.appendChild( this.renderer.domElement );\n\n\t\tthis.stats = new Stats();\n\t\tthis.container.appendChild( this.stats.dom );\n\t}\n\n\tpublic showHideGrid( visibility ){\n\t\tif( visibility == \"Show\" )\n\t\t\tthis.scene.add( this.grid );\n\t\telse\n\t\t\tthis.scene.remove( this.grid );\n\t}\n\n\tpublic createGraphics( mapWidth, mapHeight, gridArray ){\n\t\tthis.createGraphicGridLines( mapWidth, mapHeight );\n\t\tthis.createLight();\n\t\tthis.firstGroundLayer = this.createGroundLayerGraphics( 'images/atlas_ground.png', mapWidth, mapHeight, gridArray );\n\t\tthis.scene.add( this.firstGroundLayer );\n\t\tthis.secondGroundLayer = this.createSecondGroundLayerGraphics( 'images/atlas_ground_2.png', mapWidth, mapHeight, gridArray );\n\t\tthis.scene.add( this.secondGroundLayer );\n\n\t}\n\n\tprivate createSecondGroundLayerGraphics( tex, mapWidth, mapHeight, gridArray ){\n\t\tvar treeTileSize = this.tileSize/2; // 64\n\t\tvar treesInPoint = Math.round(Math.sqrt(treeTileSize)); //8\n\t\tvar stepTree = Math.floor(this.tileSize / Math.sqrt(treesInPoint));\n\t\tvar loader = new THREE.TextureLoader();\n\t\tvar texture = loader.load( tex );\n\t\tvar material = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture , shininess: 0, transparent: true, opacity: 1} );\n\t\tvar trees = new Array();\n\t\tvar mountains = new Array();\n\t\t\n\t\t//trees\n\t\ttrees.push( [new THREE.Vector2(0, .75), new THREE.Vector2(.125, .75), new THREE.Vector2(.125, .875), new THREE.Vector2(0, .875)] );\n\t\ttrees.push( [new THREE.Vector2(.125, .75), new THREE.Vector2(.25, .75), new THREE.Vector2(.25, .875), new THREE.Vector2(.125, .875)] );\n\t\ttrees.push( [new THREE.Vector2(.25, .75), new THREE.Vector2(.375, .75), new THREE.Vector2(.375, .875), new THREE.Vector2(.25, .875)] );\n\t\ttrees.push( [new THREE.Vector2(.375, .75), new THREE.Vector2(.5, .75), new THREE.Vector2(.5, .875), new THREE.Vector2(.375, .875)] );\n\t\ttrees.push( [new THREE.Vector2(.5, .75), new THREE.Vector2(.625, .75), new THREE.Vector2(.625, .875), new THREE.Vector2(.5, .875)] );\n\t\ttrees.push( [new THREE.Vector2(.625, .75), new THREE.Vector2(.75, .75), new THREE.Vector2(.75, .875), new THREE.Vector2(.625, .875)] );\n\t\ttrees.push( [new THREE.Vector2(0, .625), new THREE.Vector2(.125, .625), new THREE.Vector2(.125, .75), new THREE.Vector2(0, .75)] );\n\t\ttrees.push( [new THREE.Vector2(.125, .625), new THREE.Vector2(.25, .625), new THREE.Vector2(.25, .75), new THREE.Vector2(.125, .75)] );\n\t\ttrees.push( [new THREE.Vector2(.25, .625), new THREE.Vector2(.375, .625), new THREE.Vector2(.375, .75), new THREE.Vector2(.25, .75)] );\n\t\ttrees.push( [new THREE.Vector2(.375, .625), new THREE.Vector2(.5, .625), new THREE.Vector2(.5, .75), new THREE.Vector2(.375, .75)] );\n\t\t//mountains\n\t\tmountains.push( [new THREE.Vector2(0, .5), new THREE.Vector2(.125, .5), new THREE.Vector2(.125, .625), new THREE.Vector2(0, .625)] );\n\t\tmountains.push( [new THREE.Vector2(.125, .5), new THREE.Vector2(.25, .5), new THREE.Vector2(.25, .625), new THREE.Vector2(.125, .625)] );\n\t\tmountains.push( [new THREE.Vector2(.25, .5), new THREE.Vector2(.375, .5), new THREE.Vector2(.375, .625), new THREE.Vector2(.25, .625)] );\n\t\tmountains.push( [new THREE.Vector2(.375, .5), new THREE.Vector2(.5, .5), new THREE.Vector2(.5, .625), new THREE.Vector2(.375, .625)] );\n\t\tmountains.push( [new THREE.Vector2(.5, .5), new THREE.Vector2(.625, .5), new THREE.Vector2(.625, .625), new THREE.Vector2(.5, .625)] );\n\t\tmountains.push( [new THREE.Vector2(.625, .5), new THREE.Vector2(.75, .5), new THREE.Vector2(.75, .625), new THREE.Vector2(.625, .625)] );\n\t\tmountains.push( [new THREE.Vector2(.75, .5), new THREE.Vector2(.875, .5), new THREE.Vector2(.875, .625), new THREE.Vector2(.75, .625)] );\n\n\t\tmountains.push( [new THREE.Vector2(0, .375), new THREE.Vector2(.125, .375), new THREE.Vector2(.125, .5), new THREE.Vector2(0, .5)] );\n\t\tmountains.push( [new THREE.Vector2(.125, .375), new THREE.Vector2(.25, .375), new THREE.Vector2(.25, .5), new THREE.Vector2(.125, .5)] );\n\t\tmountains.push( [new THREE.Vector2(.25, .375), new THREE.Vector2(.375, .375), new THREE.Vector2(.375, .5), new THREE.Vector2(.25, .5)] );\n\t\tmountains.push( [new THREE.Vector2(.375, .375), new THREE.Vector2(.5, .375), new THREE.Vector2(.5, .5), new THREE.Vector2(.375, .5)] );\n\t\tmountains.push( [new THREE.Vector2(.5, .375), new THREE.Vector2(.625, .375), new THREE.Vector2(.625, .5), new THREE.Vector2(.5, .5)] );\n\t\tmountains.push( [new THREE.Vector2(.625, .375), new THREE.Vector2(.75, .375), new THREE.Vector2(.75, .5), new THREE.Vector2(.625, .5)] );\n\t\tmountains.push( [new THREE.Vector2(.75, .5), new THREE.Vector2(.875, .5), new THREE.Vector2(.875, .625), new THREE.Vector2(.75, .625)] );\n\t\t\n\t\tmountains.push( [new THREE.Vector2(0, .25), new THREE.Vector2(.125, .25), new THREE.Vector2(.125, .375), new THREE.Vector2(0, .375)] );\n\t\tmountains.push( [new THREE.Vector2(.125, .25), new THREE.Vector2(.25, .25), new THREE.Vector2(.25, .375), new THREE.Vector2(.125, .375)] );\n\t\tmountains.push( [new THREE.Vector2(.25, .25), new THREE.Vector2(.375, .25), new THREE.Vector2(.375, .375), new THREE.Vector2(.25, .375)] );\n\t\tmountains.push( [new THREE.Vector2(.375, .25), new THREE.Vector2(.5, .25), new THREE.Vector2(.5, .375), new THREE.Vector2(.375, .375)] );\n\t\tmountains.push( [new THREE.Vector2(.5, .25), new THREE.Vector2(.625, .25), new THREE.Vector2(.625, .375), new THREE.Vector2(.5, .375)] );\n\t\tmountains.push( [new THREE.Vector2(.625, .25), new THREE.Vector2(.75, .25), new THREE.Vector2(.75, .375), new THREE.Vector2(.625, .375)] );\n\t\tmountains.push( [new THREE.Vector2(.75, .25), new THREE.Vector2(.875, .25), new THREE.Vector2(.875, .375), new THREE.Vector2(.75, .375)] );\n\t\t//city\n\t\tvar city = [new THREE.Vector2(0, .875), new THREE.Vector2(.125, .875), new THREE.Vector2(.125, 1), new THREE.Vector2(0, 1)];\n\n\t\tvar meshArray = new Array(); \n\n\t\tvar sizeWithStepHeight = (this.tileSize*mapHeight)/2;\n\t\tvar sizeWithStepWidth = (this.tileSize*mapWidth)/2;\n\t\tvar y = -sizeWithStepHeight;\n\n\t\tfor ( var i = 0 ; i < mapHeight; i++ ){\n\t\t\tvar x = -sizeWithStepWidth;\n\n\t\t\tfor ( var j = 0; j < mapWidth; j++ ){\n\t\t\t\tvar pointId = i*mapHeight + j;\n\t\t\t\tvar point = gridArray[pointId];\n\t\t\t\tvar mesh;\n\n\t\t\t\tif( point.coverType == 7 ){\n\t\t\t\t\t//create forest ( trees );\n\t\t\t\t\tfor( var k = -treeTileSize; k <= treeTileSize; k += stepTree ){\n\t\t\t\t\t\tfor( var l = -treeTileSize; l <= treeTileSize; l += stepTree ){\n\t\t\t\t\t\t\tvar num = Math.random();\n\t\t\t\t\t\t\tif( num <= 0.5){\n\t\t\t\t\t\t\t\t//create tree;\n\t\t\t\t\t\t\t\tvar rnum = Math.floor(Math.random()*(trees.length));\n\t\t\t\t\t\t\t\tvar newTreeGeometry = trees[rnum];\n\t\t\t\t\t\t\t\tvar planeGeometry = new THREE.PlaneGeometry( this.tileSize/2, this.tileSize/2, 1 );\n\t\t\t\t\t\t\t\tplaneGeometry.faceVertexUvs[0] = [];\n\t\t\t\t\t\t\t\tplaneGeometry.faceVertexUvs[0][0] = [ newTreeGeometry[0], newTreeGeometry[1], newTreeGeometry[3] ];\n\t\t\t\t\t\t\t\tplaneGeometry.faceVertexUvs[0][1] = [ newTreeGeometry[1], newTreeGeometry[2], newTreeGeometry[3] ];\n\t\t\t\t\t\t\t\tmesh = new THREE.Mesh( planeGeometry, material );\n\t\t\t\t\t\t\t\tmesh.rotateY(0.7584);\n\t\t\t\t\t\t\t\tmesh.rotateZ(1.5708);\n\t\t\t\t\t\t\t\tmesh.position.set(x + k - 4, treeTileSize/2, y + l - 4);\n\t\t\t\t\t\t\t\tmeshArray.push( mesh );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if( point.coverType == 8 ){\n\t\t\t\t\t//create rocks\n\t\t\t\t\tvar rnum = Math.floor(Math.random()*(mountains.length));\n\t\t\t\t\tvar newRockGeometry = mountains[rnum];\n\t\t\t\t\tvar planeGeometry = new THREE.PlaneGeometry( this.tileSize, this.tileSize, 1 );\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0] = [];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][0] = [ newRockGeometry[0], newRockGeometry[1], newRockGeometry[3] ];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][1] = [ newRockGeometry[1], newRockGeometry[2], newRockGeometry[3] ];\n\t\t\t\t\tmesh = new THREE.Mesh( planeGeometry, material );\n\t\t\t\t\tmesh.rotateY(0.7584);\n\t\t\t\t\tmesh.rotateZ(1.5708);\n\t\t\t\t\tmesh.position.set( x + this.tileSize/2, this.tileSize/2, y + this.tileSize/2 );\n\t\t\t\t\tmeshArray.push( mesh );\n\t\t\t\t}\n\t\t\t\telse if( point.coverType == 9 ){\n\t\t\t\t\t//create city\n\t\t\t\t\tvar planeGeometry = new THREE.PlaneGeometry( this.tileSize, this.tileSize, 1 );\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0] = [];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][0] = [ city[0], city[1], city[3] ];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][1] = [ city[1], city[2], city[3] ];\n\t\t\t\t\tmesh = new THREE.Mesh( planeGeometry, material );\n\t\t\t\t\tmesh.rotateY(0.7584);\n\t\t\t\t\tmesh.rotateZ(1.5708);\n\t\t\t\t\tmesh.position.set( x + this.tileSize/2, this.tileSize/2, y + this.tileSize/2 );\n\t\t\t\t\tmeshArray.push( mesh );\n\t\t\t\t}\n\n\t\t\t\tx += this.tileSize;\n\t\t\t}\n\n\t\t\ty += this.tileSize;\n\t\t}\n\n\t\tvar geometry = this.megreMeshes( meshArray );\n\t\tvar newMesh = new THREE.Mesh( geometry, material);\n\t\t//newMesh.castShadow = true;\n\t\treturn newMesh;\n\t}\n\n\tprivate createGroundLayerGraphics( newTexture, gridSizeHeight, gridSizeWidth, gridArray ){\n\n\t\tvar solidArray = new Array();\n\t\tvar liquidArray = new Array();\n\n\t\tvar planeGeometry; //ground tile;\n\t\tvar textureLoader = new THREE.TextureLoader();\n\t\tvar tex = textureLoader.load( newTexture );\n\n\t\tvar solidMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff , map:tex, shininess: 0, side: THREE.DoubleSide } );\n\t\tvar liquidMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff , map:tex, shininess: 25 } );\n\n\t\tvar sand = [new THREE.Vector2(.01, .76), new THREE.Vector2(.24, .76), new THREE.Vector2(.24, .99), new THREE.Vector2(.01, .99)];\n\t\tvar road = [new THREE.Vector2(.26, .76), new THREE.Vector2(.49, .76), new THREE.Vector2(.49, .99), new THREE.Vector2(.26, .99)];\n\t\tvar rock = [new THREE.Vector2(.51, .76), new THREE.Vector2(.74, .76), new THREE.Vector2(.74, .99), new THREE.Vector2(.51, .99)];\n\t\tvar lava = [new THREE.Vector2(.76, .76), new THREE.Vector2(.99, .76), new THREE.Vector2(.99, .99), new THREE.Vector2(.76, .99)];\n\t\tvar earth = [new THREE.Vector2(.01, .51), new THREE.Vector2(.24, .51), new THREE.Vector2(.24, .74), new THREE.Vector2(.01, .74)];\n\t\tvar water = [new THREE.Vector2(.26, .51), new THREE.Vector2(.49, .51), new THREE.Vector2(.49, .74), new THREE.Vector2(.26, .74)];\n\t\tvar swamp = [new THREE.Vector2(.51, .51), new THREE.Vector2(.74, .51), new THREE.Vector2(.74, .74), new THREE.Vector2(.51, .74)];\n\t\tvar oil = [new THREE.Vector2(.76, .51), new THREE.Vector2(.99, .51), new THREE.Vector2(.99, .74), new THREE.Vector2(.76, .74)];\n\t\tvar city = [new THREE.Vector2(.01, .26), new THREE.Vector2(.24, .26), new THREE.Vector2(.24, .49), new THREE.Vector2(.01, .49)];\n\t\tvar forest = [new THREE.Vector2(.26, .26), new THREE.Vector2(.49, .26), new THREE.Vector2(.49, .49), new THREE.Vector2(.26, .49)];\n\n\t\tvar mesh;\n\t\tvar sizeWithStepHeight = (this.tileSize*gridSizeHeight)/2;\n\t\tvar sizeWithStepWidth = (this.tileSize*gridSizeWidth)/2;\n\t\tvar y = -sizeWithStepHeight;\n\t\t // 0 - free ; 1 - water; 2 - lava; 3 - swamp; 4 - earth; 5 - sand; 6 - road; 7 - forest; 8 - rocks; 9 - city;\n\t\tfor ( var i = 0 ; i < gridSizeHeight; i++ ){\n\t\t\tvar x = -sizeWithStepWidth;\n\n\t\t\tfor ( var j = 0; j < gridSizeWidth; j++ ){\n\t\t\t\tvar pointId = i*gridSizeHeight + j;\n\t\t\t\tvar point = gridArray[pointId];\n\t\t\t\tplaneGeometry = new THREE.PlaneGeometry( this.tileSize, this.tileSize, 1 );\n\n\t\t\t\tif( point.coverType == 0 ){\n\t\t\t\t\t//create free; now it's oil;\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0] = [];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][0] = [ oil[0], oil[1], oil[3] ];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][1] = [ oil[1], oil[2], oil[3] ];\n\t\t\t\t\tmesh = new THREE.Mesh( planeGeometry, liquidMaterial );\n\t\t\t\t\tmesh.rotateX(-1.5708);\n\t\t\t\t\tmesh.position.set(x, 0, y);\n\t\t\t\t\tliquidArray.push( mesh );\n\t\t\t\t}\n\t\t\t\telse if( point.coverType == 1 ){\n\t\t\t\t\t//create water;\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0] = [];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][0] = [ water[0], water[1], water[3] ];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][1] = [ water[1], water[2], water[3] ];\n\t\t\t\t\tmesh = new THREE.Mesh( planeGeometry, liquidMaterial );\n\t\t\t\t\tmesh.rotateX(-1.5708);\n\t\t\t\t\tmesh.position.set(x, 0, y);\n\t\t\t\t\tliquidArray.push( mesh );\n\t\t\t\t}\n\t\t\t\telse if( point.coverType == 2 ){\n\t\t\t\t\t//create lava;\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0] = [];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][0] = [ lava[0], lava[1], lava[3] ];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][1] = [ lava[1], lava[2], lava[3] ];\n\t\t\t\t\tmesh = new THREE.Mesh( planeGeometry, solidMaterial );\n\t\t\t\t\tmesh.rotateX(-1.5708);\n\t\t\t\t\tmesh.position.set(x, 0, y);\n\t\t\t\t\tsolidArray.push( mesh );\n\t\t\t\t}\n\t\t\t\telse if( point.coverType == 3 ){\n\t\t\t\t\t//create swamp;\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0] = [];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][0] = [ swamp[0], swamp[1], swamp[3] ];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][1] = [ swamp[1], swamp[2], swamp[3] ];\n\t\t\t\t\tmesh = new THREE.Mesh( planeGeometry, solidMaterial );\n\t\t\t\t\tmesh.rotateX(-1.5708);\n\t\t\t\t\tmesh.position.set(x, 0, y);\n\t\t\t\t\tsolidArray.push( mesh );\n\t\t\t\t}\n\t\t\t\telse if( point.coverType == 4 ){\n\t\t\t\t\t//create earth;\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0] = [];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][0] = [ earth[0], earth[1], earth[3] ];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][1] = [ earth[1], earth[2], earth[3] ];\n\t\t\t\t\tmesh = new THREE.Mesh( planeGeometry, solidMaterial );\n\t\t\t\t\tmesh.rotateX(-1.5708);\n\t\t\t\t\tmesh.position.set(x, 0, y);\n\t\t\t\t\tsolidArray.push( mesh );\n\t\t\t\t}\n\t\t\t\telse if( point.coverType == 5 ){\n\t\t\t\t\t//create sand;\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0] = [];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][0] = [ sand[0], sand[1], sand[3] ];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][1] = [ sand[1], sand[2], sand[3] ];\n\t\t\t\t\tmesh = new THREE.Mesh( planeGeometry, solidMaterial );\n\t\t\t\t\tmesh.rotateX(-1.5708);\n\t\t\t\t\tmesh.position.set(x, 0, y);\n\t\t\t\t\tsolidArray.push( mesh );\n\t\t\t\t}\n\t\t\t\telse if( point.coverType == 6 ){\n\t\t\t\t\t//create road;\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0] = [];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][0] = [ road[0], road[1], road[3] ];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][1] = [ road[1], road[2], road[3] ];\n\t\t\t\t\tmesh = new THREE.Mesh( planeGeometry, solidMaterial );\n\t\t\t\t\tmesh.rotateX(-1.5708);\n\t\t\t\t\tmesh.position.set(x, 0, y);\n\t\t\t\t\tsolidArray.push( mesh );\n\t\t\t\t}\n\t\t\t\telse if( point.coverType == 7 ){\n\t\t\t\t\t//create forest\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0] = [];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][0] = [ forest[0], forest[1], forest[3] ];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][1] = [ forest[1], forest[2], forest[3] ];\n\t\t\t\t\tmesh = new THREE.Mesh( planeGeometry, solidMaterial );\n\t\t\t\t\tmesh.rotateX(-1.5708);\n\t\t\t\t\tmesh.position.set(x, 0, y);\n\t\t\t\t\tsolidArray.push( mesh );\n\t\t\t\t}\n\t\t\t\telse if( point.coverType == 8 ){\n\t\t\t\t\t//create rock\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0] = [];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][0] = [ rock[0], rock[1], rock[3] ];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][1] = [ rock[1], rock[2], rock[3] ];\n\t\t\t\t\tmesh = new THREE.Mesh( planeGeometry, solidMaterial );\n\t\t\t\t\tmesh.rotateX(-1.5708);\n\t\t\t\t\tmesh.position.set(x, 0, y);\n\t\t\t\t\tsolidArray.push( mesh );\n\t\t\t\t}\n\t\t\t\telse if( point.coverType == 9 ){\n\t\t\t\t\t//create city;\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0] = [];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][0] = [ city[0], city[1], city[3] ];\n\t\t\t\t\tplaneGeometry.faceVertexUvs[0][1] = [ city[1], city[2], city[3] ];\n\t\t\t\t\tmesh = new THREE.Mesh( planeGeometry, solidMaterial );\n\t\t\t\t\tmesh.rotateX(-1.5708);\n\t\t\t\t\tmesh.position.set(x, 0, y);\n\t\t\t\t\tsolidArray.push( mesh );\n\t\t\t\t}\n\n\t\t\t\tx += this.tileSize;\n\t\t\t}\n\t\t\ty += this.tileSize;\n\t\t}\n\n\t\t//merge meshes to 1 global mesh;\n\t\tvar solidGeometry = this.megreMeshes( solidArray );\n\t\tvar liquidGeometry  = this.megreMeshes( liquidArray );\t\t\n\n\t\tvar solidMesh = new THREE.Mesh( solidGeometry, solidMaterial );\n\t\t//earthMesh.receiveShadow = true;\n\t\tvar liquidMesh = new THREE.Mesh( liquidGeometry, liquidMaterial );\n\n\t\tvar group = new THREE.Group();\n\n\t\tgroup.add( solidMesh );\n\t\tgroup.add( liquidMesh );\n\n\t\treturn group;\t\t\n\t}\n\n\tprivate createLight(){\n\t\t//ambientLight;\n\t\t//var ambientLight = new THREE.AmbientLight( 0x404040 );\n\t\t//scene.add( ambientLight );\n\t\t\n\t\tthis.hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffdf, 0.6 );\n\t\tthis.hemiLight.position.set(0, 500, 0);\n\t\tthis.scene.add( this.hemiLight );\n\n\t\t//direction light;\n\t\tthis.directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );\n\t\tthis.directionalLight.position.set( 0, 0.75, 0 ).normalize();\n\t\tthis.scene.add( this.directionalLight );\n\t\t//var targetObject = new THREE.Object3D();\n\t\t//scene.add(targetObject);\n\t\t//directionalLight.target = targetObject;\n\n\t\t//spot light\n\t\tthis.spotLight = new THREE.SpotLight( 0xfffffd, 0.25, 0, 1.05, 1, 1 ); //color, intensity, distance, angle, penumbra, decay\n\t\tthis.spotLight.position.set( 10000, 10000, 10000 );\n\t\t//spotLight.castShadow = true;\n\t\t//spotLight.shadow.mapSize.width = 1024;\n\t\t//spotLight.shadow.mapSize.height = 1024;\n\t\t//spotLight.shadow.camera.near = 500;\n\t\t//spotLight.shadow.camera.far = 4000;\n\t\t//spotLight.shadow.camera.fov = 30;\n\t\tthis.scene.add( this.spotLight );\n\t}\n\n\t// Grid\n\tprivate createGraphicGridLines( gridSizeHeight, gridSizeWidth):void{\n\t\tvar geometry = new THREE.Geometry();\n\t\tvar sizeWithStepHeight = (this.tileSize*gridSizeHeight)/2;\n\t\tvar sizeWithStepWidth = (this.tileSize*gridSizeWidth)/2;\n\n\t\tfor (var y = -sizeWithStepHeight; y <= sizeWithStepHeight; y += this.tileSize){\n\t\t\tfor (var x = -sizeWithStepWidth; x <= sizeWithStepWidth; x += this.tileSize){\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3( x, 0, -y ) );\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3(   x, 0, y ) );\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3( -y, 0, x ) );\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3( y, 0,   x ) );\n\t\t\t}\n\t\t}\n\n\t\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, opacity: 0.2 } );\n\t\tthis.grid = new THREE.LineSegments( geometry, material );\n\t\tthis.grid.position.x -= this.tileSize/2;\n\t\tthis.grid.position.z -= this.tileSize/2;\n\t\tthis.scene.add( this.grid );\n\t}\n\n\tprivate megreMeshes( arrayOfMeshes ):any{\n\t\tvar geometry = new THREE.Geometry();\n\t\tfor ( var i = 0; i < arrayOfMeshes.length; i++ ){\n\t\t\tarrayOfMeshes[i].updateMatrix();\n\t\t\tgeometry.merge( arrayOfMeshes[i].geometry, arrayOfMeshes[i].matrix );\n\t\t}\n\t\treturn geometry;\n\t}\n}\n\n\nclass EntityRoot{\n\n\tpublic entitiesArray:Array<any>;\n\n\tconstructor(){\n\t\tthis.entitiesArray = new Array();\n\t}\n\n\tpublic createEntity( type ):any{\n\t\tvar entity;\n\t\tvar name;\n\t\tvar id = this.createId();\n\n\t\tif( type == \"Player\" ){\n\t\t\tname = \"Player\";\n\t\t}\n\t\telse if( type == \"City\" ){\n\t\t\tname = \"City\";\n\t\t}\n\t\telse if( type == \"Mob\" ){\n\t\t\tname = 'Mob';\n\t\t}\n\t\telse if( type == \"NPC\" ){\n\t\t\tname = \"NPC\";\n\t\t}\n\n\t\tentity = new Entity( name, id );\n\t\tthis.entitiesArray.push( entity );\n\n\t\treturn entity;\n\t}\n\n\tpublic removeEntity( id ):any{\n\t\tvar index = -1;\n\t\tvar result = null;\n\t\tfor( var i = 0; i < this.entitiesArray.length; i++ ){\n\t\t\tvar entity = this.entitiesArray[i];\n\t\t\tif( entity.getComponent( 'Type' ).entityId == id ){\n\t\t\t\tresult = entity;\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.entitiesArray.splice( index, 1 );\n\n\t\treturn result;\n\t}\n\n\tprivate createId(){\n\t\tvar id = \"0\";\n\t\treturn id;\n\t}\n\n}\n\n\nclass Entity {\n\n\tprivate components:Array<any>;\n\n\tconstructor( name, id ){\n\t\tthis.components = new Array();\n\t\tthis.init( name, id );\n\t}\n\n\tprivate init( name, id ){\n\t\tvar component = this.createComponent( 'Type' );\n\t\tcomponent.init( name, id );\n\t\tthis.addComponent( component );\n\t}\n\n\tpublic createComponent( componentName ):any{\n\t\tvar component;\n\t\tif( componentName == \"City\" )\n\t\t\tcomponent = new City( this );\n\t\telse if( componentName == \"Name\" )\n\t\t\tcomponent = new Name( this );\n\t\telse if( componentName == \"Type\")\n\t\t\tcomponent = new Type( this );\n\t\telse if( componentName == \"GridPosition\" )\n\t\t\tcomponent = new GridPosition( this );\n\t\telse if( componentName == \"Move\" )\n\t\t\tcomponent = new Move( this );\n\t\telse if( componentName == \"Draw\" )\n\t\t\tcomponent = new Draw( this );\n\t\telse if( componentName == \"Type\" )\n\t\t\tcomponent = new Type( this );\n\t\telse{\n\t\t\tconsole.log( \"Not found component with name: \" + componentName + \"; Error in Entity/createComponent\");\n\t\t\treturn null;\n\t\t}\n\t\treturn component;\n\t}\n\n\tpublic addComponent(component):void{\n\t\tvar index = this.checkComponentInComponents(component);\n\t\tcomponent.changeParent( this ); // меняем родителя, если вдруг по каким-то причинам компонент создала другая Entity.\n\t\tif (index == 0){\n\t\t\tthis.components.push(component);\n\t\t}else{\n\t\t\tthis.components[index] = component;\n\t\t}\n\t}\n\n\tpublic removeComponent( componentName ):any{\n\t\tvar component;\n\t\tvar index = -1;\n\t\tfor( var i = 0; i < this.components.length; i++ ){\n\t\t\tvar curComponent = this.components[i].componentName;\n\t\t\tif( curComponent == componentName ){\n\t\t\t\tcomponent = this.components[i];\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.components.splice( index, 1 );\n\t\treturn component;\n\t}\n\n\tpublic getComponent(componentName):any{\n\t\tfor (var i = 0; i < this.components.length; i++){\n\t\t\tif (this.components[i].componentName == componentName)\n\t\t\t\treturn this.components[i];\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate checkComponentInComponents(component):number{\n\t\tvar newComponentName = component.componentName;\n\t\tfor (var i = 0; i < this.components.length; i++){\n\t\t\tif (this.components[i].componentName == newComponentName)\n\t\t\t\treturn i;\t\t\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tpublic update(dx):void{\n\t\tfor (var i = 0; i < this.components.length; i++){\n\t\t\tthis.components[i].update(dx);\n\t\t}\n\t}\n}\n\nclass Component {\n\tpublic componentName:string;\n\n\tprotected parent:any;\n\n\tconstructor( newName, parent ){\n\t\tthis.componentName = newName;\n\t\tthis.parent = parent;\n\t}\n\n\tpublic update( dx ):void{\n\n\t}\n\n\tpublic changeParent( newParent ):void{\n\t\tthis.parent = newParent;\n\t}\n}\n\nclass City extends Component {\n\n\tpublic roadAmount:number;\n\tpublic roadToCities:Array<string>; // контейнер для генератора, что бы понять, что город соединен с другим городом и дополнительная дорога не нужна;\n\n\tconstructor( parent ){\n\t\tsuper(\"City\", parent);\n\t\tthis.roadAmount = 0;\n\t\tthis.roadToCities = new Array();\n\t}\n\n\tpublic checkRoadToCity( cityName ):boolean{\n\t\tfor (var i = 0 ; i < this.roadToCities.length; i++){\n\t\t\tif (cityName == this.roadToCities[i])\n\t\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic addRoadToCity( cityName ):void{\n\t\tthis.roadToCities.push( cityName );\n\t}\n}\n\nclass Name extends Component{\n\tpublic name:string;\n\tpublic surname:string;\n\n\tprivate namesArray:Array<any>;\n\tprivate surnamesArray:Array<any>;\n\n\tconstructor( parent ){\n\t\tsuper(\"Name\", parent );\n\t}\n\n\tpublic init( namesArray, surnamesArray ){\n\t\tthis.namesArray = namesArray;\n\t\tthis.surnamesArray = surnamesArray;\n\t}\n\n\tpublic generateName( sex ):void{\n\t\tvar firstPartName = this.namesArray[0];\n\t\tvar secondPartName = this.namesArray[1];\n\t\tvar thirdPartNameMale = this.namesArray[2];\n\t\tvar thirdPartNameFemale = this.namesArray[3];\n\n\t\tvar fname = Math.floor(Math.random()*firstPartName.length);\n\t\tvar sname = Math.floor(Math.random()*secondPartName.length);\n\t\tvar tname;\n\t\tif (sex == 0){ // 0 - man;\n\t\t\ttname = thirdPartNameMale[Math.floor(Math.random()*thirdPartNameMale.length)];\n\t\t}else{\n\t\t\ttname = thirdPartNameFemale[Math.floor(Math.random()*thirdPartNameFemale.length)];\n\t\t}\n\n\t\tthis.name = firstPartName[fname] + secondPartName[sname] + tname;\n\t\t\n\t}\n\n\tprivate generateSurname():void{ \n\t\tvar firstPartSurname = this.surnamesArray[0];\n\t\tvar secondPartSurname = this.surnamesArray[1];\n\t\tvar thirdPartSurname = this.surnamesArray[2];\n\n\t\tvar fname = Math.floor(Math.random()*firstPartSurname.length);\n\t\tvar sname = Math.floor(Math.random()*secondPartSurname.length);\n\t\tvar tname = Math.floor(Math.random()*thirdPartSurname.length);\n\n\t\tthis.surname = firstPartSurname[fname] + secondPartSurname[sname] + thirdPartSurname[tname];\n\t\t\t\n\t}\n\n}\n\nclass Move extends Component{\n\n\tpublic x:number;\n\tpublic y:number;\n\n\tprivate halfTileSize:number;\n\tprivate gridTileSize:number;\n\n\tconstructor( parent ){\n\t\tsuper( \"Move\", parent );\n\t}\n\n\tpublic init( gridTileSize, tileSize, x, y ):void{\n\t\tthis.halfTileSize = tileSize/2;\n\t\tthis.gridTileSize = gridTileSize;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic move( x, y ):void{\n\t\tthis.x += x;\n\t\tthis.y += y;\n\n\t\tthis.gridMove();\n\n\t}\n\n\tprivate gridMove():void{\n\t\tvar gridX = Math.floor( this.x/this.gridTileSize + this.halfTileSize );\n\t\tvar gridY = Math.floor( this.y/this.gridTileSize + this.halfTileSize );\n\n\t\tvar component = this.parent.getComponent( \"GridPosition\" );\n\t\tcomponent.position.x = gridX;\n\t\tcomponent.position.y = gridY;\n\t}\n}\n\nclass Draw extends Component{\n\n\tpublic graphicIndex:number;\n\tpublic tileSize:number;\n\n\tconstructor( parent ){\n\t\tsuper( \"Draw\", parent );\n\t}\n\n\tpublic init( tileSize ):void{\n\t\tthis.tileSize = tileSize;\n\t}\n}\n\nclass GridPosition extends Component{\n\n\tpublic position:any;\n\tpublic gridId:number;\n\n\tconstructor( parent ){\n\t\tsuper( \"GridPosition\", parent);\n\t\tthis.position = new GridCoordinates( 0, 0 );\n\t}\n\n\tpublic changePosition( x, y ){\n\t\tthis.position.x = x;\n\t\tthis.position.y = y;\n\t}\n}\n\nclass Type extends Component{\n\n\tpublic entityName:string;\n\tpublic entityId:string;\n\n\tconstructor( parent ){\n\t\tsuper( \"Type\", parent );\t\t\n\t}\n\n\tpublic init( name, entityId ){\n\t\tthis.entityName = name;\n\t\tthis.entityId = entityId;\n\t}\n}\n",
			"file": "js/framework/classes.ts",
			"file_size": 41115,
			"file_write_time": 131317036333405509,
			"settings":
			{
				"buffer_size": 39316,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "index.html",
			"settings":
			{
				"buffer_size": 1874,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "text.txt",
			"settings":
			{
				"buffer_size": 744,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/projects/webgl-threejs"
	],
	"file_history":
	[
		"/C/projects/webgl-threejs/js/data/npcNamesSurnames.js",
		"/C/projects/webgl-threejs/js/framework/classes.js",
		"/C/projects/webgl+three_js/Lets test it/index.html",
		"/C/projects/webgl+three_js/Lets test it/js/framework/classes.ts",
		"/C/projects/webgl+three_js/Lets test it/js/game.js",
		"/C/projects/webgl+three_js/Lets test it/js/services.js",
		"/C/projects/webgl+three_js/Lets test it/js/framework/generators.js",
		"/C/projects/webgl+three_js/Lets test it/js/graphics.js",
		"/C/projects/webgl+three_js/Lets test it/js/classes.ts",
		"/C/Users/Admin/Desktop/shoot-them-all-master/index.html",
		"/C/Users/Admin/Desktop/shoot-them-all-master/main.js",
		"/C/Users/Admin/Desktop/shoot-them-all-master/index.css",
		"/C/Users/Admin/Desktop/Новый текстовый документ.html",
		"/C/projects/webgl+three_js/Lets test it/js/classes.js",
		"/C/Users/Admin/Desktop/generateName.html",
		"/C/projects/DieAnotherDay_v0.11/source/EntitySystem.hx",
		"/C/projects/DieAnotherDay_v0.11/source/Entity.hx",
		"/C/projects/DieAnotherDay_v0.11/source/GameTile.hx",
		"/C/projects/DieAnotherDay_v0.11/source/UserInterface.hx",
		"/C/projects/DieAnotherDay_v0.11/source/PlayingScene.hx",
		"/C/projects/DieAnotherDay_v0.11/Export/html5/release/bin/index.html",
		"/C/projects/DieAnotherDay_v0.11/.gitignore",
		"/C/projects/DieAnotherDay_v0.11/source/Move.hx",
		"/C/projects/DieAnotherDay_v0.11/source/Draw.hx",
		"/C/projects/DieAnotherDay_v0.11/source/LifeCircle.hx",
		"/C/projects/BunnyMark/Source/Main.hx",
		"/C/projects/test/SampleProject/project.xml",
		"/C/projects/BunnyMark/Source/Bunny.hx",
		"/C/projects/DieAnotherDay_v0.11_old/source/Entity.hx",
		"/C/projects/DieAnotherDay_v0.11/source/StartingScene.hx",
		"/C/projects/DieAnotherDay_v0.11/source/SceneSystem.hx",
		"/C/projects/DieAnotherDay_v0.11/source/GameSystem.hx",
		"/C/projects/DieAnotherDay_v0.11/source/Coordinates.hx",
		"/C/projects/DieAnotherDay_v0.11/source/Main.hx",
		"/C/projects/DieAnotherDay_v0.11/source/Game.hx",
		"/C/projects/DieAnotherDay/source/PlayingScene.hx",
		"/C/projects/DieAnotherDay/source/TileMap.hx",
		"/C/projects/DieAnotherDay_v0.11/source/Scene.hx",
		"/C/projects/DieAnotherDay/source/Tiles.hx",
		"/C/projects/DieAnotherDay_v0.11/source/Tile.hx",
		"/C/projects/DieAnotherDay/source/UserInterface.hx",
		"/C/projects/DieAnotherDay/source/Game.hx",
		"/C/projects/DieAnotherDay_v0.11/source/LevelSystem.hx",
		"/C/projects/DieAnotherDay/source/SceneCharacterActor.hx",
		"/C/projects/DieAnotherDay/source/WelcomeScene.hx",
		"/C/projects/DieAnotherDay/source/Main.hx",
		"/C/projects/DieAnotherDay_v0.11/project.xml",
		"/C/projects/DieAnotherDay/source/PathfinderMap.hx",
		"/C/projects/Noname/Data/Scripts/Main.cpp",
		"/C/projects/New_DieAnotherDay/source/Game.hx",
		"/C/Users/aakorolev/Downloads/pathfinder-master/demo/src/demo/MapData.hx",
		"/C/Users/aakorolev/Downloads/pathfinder-master/demo/src/Config.hx",
		"/C/Users/aakorolev/Downloads/pathfinder-master/demo/src/Main.hx",
		"/C/projects/DieAnotherDay/source/pathfinder/PathfinderMap.hx",
		"/C/projects/pathfinder-master/lib/pathfinder/Coordinate.hx",
		"/C/projects/haxe-astar-master/haxe-astar/src/Main.hx",
		"/C/projects/haxe-astar-master/haxe-astar/src/statm/explore/haxeAStar/AStar.hx",
		"/C/projects/haxe-astar-master/README.md",
		"/C/Users/Admin/Desktop/no_title.html",
		"/C/Users/Admin/Documents/GitHub/shoot-them-all/main.js",
		"/C/Users/Admin/Documents/GitHub/shoot-them-all/index.html",
		"/C/Users/Admin/Documents/GitHub/hory-card-v2.0/index.html",
		"/C/Users/Admin/Documents/GitHub/hory-card-v2.0/battle.js",
		"/C/projects/openfl-samples-master/demos/HerokuShaders/Source/Main.hx",
		"/C/projects/openfl-samples-master/demos/NyanCat/Source/Main.hx",
		"/C/projects/openfl-samples-master/demos/PiratePig/Source/piratepig/Tile.hx",
		"/C/projects/openfl-samples-master/demos/BunnyMark/Source/Main.hx",
		"/C/projects/openfl-samples-master/demos/PiratePig/Source/piratepig/PiratePigGame.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/SceneActor.hx",
		"/C/projects/DieAnotherDay/project.xml",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/UserInterface.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/Scene.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/Game.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/ScenePlayerActor.hx",
		"/C/projects/openfl-samples-master/demos/TextAlignment/Source/Main.hx",
		"/C/projects/openfl-samples-master/demos/BunnyMark/Source/Bunny.hx",
		"/C/projects/openfl-samples-master/demos/PiratePig/Source/piratepig/PiratePig.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/GameTurnControl.hx",
		"/C/projects/DieAnotherDay/source/Tile.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/ContactListener.hx",
		"/C/projects/DieAnotherDay/.gitignore",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/Main.hx",
		"/C/projects/DieAnotherDay/source/Ball.hx",
		"/C/projects/DieAnotherDay/source/Platform.hx",
		"/C/projects/DieAnotherDay/DisplayingABitmap/Source/Main.hx",
		"/C/projects/DieAnotherDay/DisplayingABitmap/project.xml",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/SceneGroundActor.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/TimeMaster.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/Weapon.hx",
		"/C/Users/Admin/AppData/Local/Temp/7zO8E55456E/HelloWorld.as",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/Input.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/BotEvent.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/SceneBotActor.hx",
		"/C/Users/Admin/Desktop/teaching/TooManyShoots/source/Camera.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/GameTimer.hx",
		"/C/Users/Admin/Desktop/teaching/TooManyShoots/source/Main.hx",
		"/C/Users/Admin/Desktop/teaching/TooManyShoots/source/PegActor.hx",
		"/C/Users/Admin/Desktop/teaching/TooManyShoots/source/PegEvent.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/EnemyEvent.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/PlayerEvent.hx",
		"/C/Users/Admin/Desktop/teaching/TooManyShoots/source/Actor.hx",
		"/C/Users/Admin/Desktop/teaching/TooManyShoots/source/PlayerActor.hx",
		"/C/Users/Admin/Desktop/teaching/TooManyShoots/source/BallEvent.hx",
		"/C/Users/Admin/Desktop/teaching/TooManyShoots/source/BonusChuteActor.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/source/Camera.hx",
		"/C/Users/Admin/Desktop/teaching/TooManyShoots/source/ArbiStaticActor.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/Project.xml",
		"/C/Users/Admin/Desktop/teaching/TooManyShoots/source/Director.hx",
		"/C/Users/Admin/Desktop/teaching/TooManyShoots/source/Global.hx",
		"/C/Users/Admin/Desktop/teaching/TooManyShoots/source/TimeMaster.hx",
		"/C/Users/Admin/Desktop/teaching/TooManyShoots/source/ContactListener.hx",
		"/C/Users/Admin/Desktop/teaching/TooManyShoots/Project.xml",
		"/C/HaxeToolkit/haxe/lib/box2d/1,2,3/samples/TestBed/Source/Main.hx",
		"/C/Users/Admin/Documents/GitHub/roaches-box2d-haxe/.gitignore",
		"/c/Users/Admin/Desktop/teaching/TooManyShoots/source/Global.hx",
		"/c/Users/Admin/Desktop/teaching/TooManyShoots/source/Actor.hx",
		"/c/Users/Admin/Desktop/teaching/TooManyShoots/source/BonusChuteActor.hx",
		"/c/Users/Admin/Desktop/teaching/TooManyShoots/source/ArbiStaticActor.hx",
		"/c/Users/Admin/Desktop/teaching/TooManyShoots/source/PegActor.hx",
		"/c/Users/Admin/Desktop/teaching/TooManyShoots/source/PlayerActor.hx",
		"/c/Users/Admin/Desktop/teaching/TooManyShoots/Project.xml",
		"/c/Users/Admin/Desktop/teaching/TooManyShoots/source/ContactListener.hx",
		"/c/Users/Admin/Desktop/teaching/TooManyShoots/source/Main.hx",
		"/C/Users/Admin/Desktop/teaching/TooManyShoots/.gitignore",
		"/c/Users/Admin/Desktop/teaching/TooManyShoots/source/BallEvent.hx",
		"/c/Users/Admin/Desktop/teaching/TooManyShoots/source/PegEvent.hx",
		"/c/Users/Admin/Desktop/teaching/TooManyShoots/source/PlayerEvent.hx",
		"/c/Users/Admin/Desktop/teaching/TooManyShoots/source/GameInfo.hx"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"();\n",
			");",
			"checkScene",
			"tileSize",
			"lastLeftPoint",
			"gridSize",
			"Tile",
			");\n",
			"reset",
			"actorToRemove",
			"));\n",
			"m_type",
			"getType",
			";\n",
			");\n",
			"setV",
			"Global.world_sprite",
			"m_physScale",
			"new",
			"m_bodyList",
			"the_w",
			"size",
			"set_size",
			"setSize",
			"12",
			"getParent",
			"removeComponent",
			"getCompon",
			"updateUIfightingLog",
			"updateUIplayerStats",
			"getData",
			"this.getData",
			"this.weapon",
			"getComponentList",
			" this.components",
			" this.parent.components.",
			"classDefenition",
			"this.bagVault.1.",
			"this.bagVault[1]"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"findScene",
			"_tileSize",
			"firstLeftPoint",
			"_gridSize",
			"Tiles",
			"world_scale",
			"w",
			"W",
			"classDefinition",
			"gun.",
			"gun"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 2,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "js/game.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1722,
						"regions":
						{
						},
						"selection":
						[
							[
								696,
								696
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "js/services.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5145,
						"regions":
						{
						},
						"selection":
						[
							[
								4295,
								4295
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 2144.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "js/framework/classes.ts",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 39316,
						"regions":
						{
						},
						"selection":
						[
							[
								1591,
								1581
							]
						],
						"settings":
						{
							"syntax": "Packages/TypeScript/TypeScript.tmLanguage",
							"translate_tabs_to_spaces": false,
							"use_tab_stops": false
						},
						"translation.x": 0.0,
						"translation.y": 415.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "index.html",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1874,
						"regions":
						{
						},
						"selection":
						[
							[
								1830,
								1830
							]
						],
						"settings":
						{
							"syntax": "Packages/HTML/HTML.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "text.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 744,
						"regions":
						{
						},
						"selection":
						[
							[
								294,
								294
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 26.0
	},
	"input":
	{
		"height": 34.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.doc":
	{
		"height": 0.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "webgl-threejs.sublime-project",
	"replace":
	{
		"height": 62.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 152.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
